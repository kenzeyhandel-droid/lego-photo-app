from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Any, Dict
from reportlab.lib.pagesizes import A4, landscape
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from io import BytesIO
from fastapi.responses import StreamingResponse, Response
import xml.etree.ElementTree as ET

app = FastAPI(title="Lego Photo Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class ColorCount(BaseModel):
    name: str
    bl_name: str
    hex: str
    count: int
    bricklink_color_id: int

class LegoMap(BaseModel):
    map: List[List[Dict[str,Any]]]
    width: int
    height: int

class PDFRequest(BaseModel):
    legoMap: LegoMap
    partsList: List[ColorCount]
    part_id: str
    stepHeight: int = 8

@app.post("/api/generate_pdf")
def generate_pdf(req: PDFRequest):
    # Create PDF with one page per stepHeight rows
    try:
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=landscape(A4))
        width_mm, height_mm = landscape(A4)
        # compute cell size to fit width
        cols = req.legoMap.width
        rows = req.legoMap.height
        # we will set margins
        margin = 15*mm
        usable_w = width_mm - 2*margin
        usable_h = height_mm - 2*margin
        cell_w = usable_w / cols
        # rows per page = floor(usable_h / cell_w)
        rows_per_page = min(req.stepHeight, rows)
        # iterate pages
        map_data = req.legoMap.map
        page = 0
        for start in range(0, rows, rows_per_page):
            end = min(rows, start + rows_per_page)
            # Draw title
            c.setFont("Helvetica-Bold", 14)
            c.drawString(margin, height_mm - margin + 5, f"Step {page+1}: rows {start+1} - {end}")
            # draw grid
            for y in range(start, end):
                for x in range(cols):
                    cell = map_data[y][x]
                    hexcol = cell.get("hex", "#FFFFFF")
                    # convert hex to rgb 0-1
                    r = int(hexcol[1:3],16)/255.0
                    g = int(hexcol[3:5],16)/255.0
                    b = int(hexcol[5:7],16)/255.0
                    c.setFillColorRGB(r,g,b)
                    cx = margin + x*cell_w
                    cy = height_mm - margin - (y-start+1)*cell_w
                    c.rect(cx, cy, cell_w, cell_w, fill=1, stroke=0)
            # parts summary bottom
            c.setFont("Helvetica", 10)
            y_text = margin/2
            c.setFillColorRGB(0,0,0)
            c.drawString(margin, y_text + 20, "Parts on this page:")
            # simple overall parts (not per-page breakdown for now)
            for idx, p in enumerate(req.partsList[:20]):
                c.drawString(margin + idx%2*200, y_text + 5 - (idx//2)*12, f"{p.name} ({p.bl_name}): {p.count}")
            c.showPage()
            page += 1
        c.save()
        buffer.seek(0)
        return StreamingResponse(buffer, media_type="application/pdf", headers={"Content-Disposition":"attachment; filename=lego_instructions.pdf"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/generate_bricklink_xml")
def generate_bricklink_xml(partsList: List[ColorCount], type: str = "round", part_id: str = "4073"):
    # Builds a BrickLink-like wanted list XML
    try:
        root = ET.Element("INVENTORY")
        name = ET.SubElement(root, "NAME")
        name.text = "Generated by Lego Photo Webapp"
        items = ET.SubElement(root, "ITEMS")
        for p in partsList:
            item = ET.SubElement(items, "ITEM")
            ET.SubElement(item, "ITEMTYPE").text = "P"  # part
            ET.SubElement(item, "ITEMID").text = str(part_id)
            ET.SubElement(item, "COLOR").text = str(p.bricklink_color_id)
            ET.SubElement(item, "MINQTY").text = str(p.count)
            ET.SubElement(item, "QTY").text = str(p.count)
        xml_bytes = ET.tostring(root, encoding="utf-8", method="xml")
        return Response(content=xml_bytes, media_type="application/xml", headers={"Content-Disposition":"attachment; filename=bricklink_wanted.xml"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
